#include "LexicalAnalyzer.hpp"
#include "Tokens.hpp"

const std::unordered_map<std::string_view, TokenType> LexicalAnalyzer::mKeywords {
    { "let", TokenType::K_LET },
    { "int", TokenType::K_TYPE },
    { "float", TokenType::K_TYPE },
    { "double", TokenType::K_TYPE },
    { "bool", TokenType::K_TYPE },
    { "char", TokenType::K_TYPE },
    { "void", TokenType::K_TYPE },
    { "null", TokenType::L_NULL },
    { "if", TokenType::K_IF },
    { "else", TokenType::K_ELSE },
    { "for", TokenType::K_FOR },
    { "while", TokenType::K_WHILE },
    { "do", TokenType::K_DO },
    { "in", TokenType::K_IN },
    { "break", TokenType::K_BREAK },
    { "ret", TokenType::K_RET },
    { "fn", TokenType::K_FN },
    { "struct", TokenType::K_STRUCT },
    { "interface", TokenType::K_INTERFACE },
    { "impl", TokenType::K_IMPL },
    { "self", TokenType::K_SELF },
    { "this", TokenType::K_THIS },
    { "import", TokenType::K_IMPORT },
    { "export", TokenType::K_EXPORT },
    { "export_default", TokenType::K_EXPORT_DEFAULT },
    { "contract", TokenType::K_CONTRACT },
    { "listener", TokenType::K_LISTENER },
    { "state", TokenType::K_STATE },
    { "init-state", TokenType::K_INIT_STATE },
    { "fail", TokenType::K_FAIL },
    { "auto-reset", TokenType::K_AUTO_RESET },
    { "auto-move", TokenType::K_AUTO_MOVE },
    { "roles", TokenType::K_ROLES },
    { "respond", TokenType::K_RESPOND },
    { "on", TokenType::K_ON },
    { "listen", TokenType::K_LISTEN },
    { "target", TokenType::K_TARGET },
    { "as", TokenType::K_AS },
    { "using", TokenType::K_USING },
    { "after", TokenType::K_AFTER },
    { "before", TokenType::K_BEFORE },
    { "async", TokenType::K_ASYNC },
    { "await", TokenType::K_AWAIT },
    { "thread", TokenType::K_THREAD },
    { "spawn", TokenType::K_SPAWN },
    { "own", TokenType::K_OWN },
    { "move", TokenType::K_MOVE },
    { "shared", TokenType::K_SHARED },
    { "share", TokenType::K_SHARE },
    { "ref", TokenType::K_REF },
    { "view", TokenType::K_VIEW },
    { "mut", TokenType::K_MUT },
    { "const", TokenType::K_CONST },
    { "thr_local", TokenType::K_THR_LOCAL },
    { "sync", TokenType::K_SYNC },
    { "infer", TokenType::K_INFER },
    { "network", TokenType::K_NETWORK }
};

const std::unordered_map<std::string_view, TokenType> LexicalAnalyzer::mOperators {
    { "=", TokenType::OP_EQUALS }
};

const std::unordered_map<char, TokenType> LexicalAnalyzer::mDelimeters {
    { ' ', TokenType::SPACE },
    { ';', TokenType::D_SEMICOLON },
    { ':', TokenType::D_COLON },
    { '(', TokenType::D_PAR_OP },
    { ')', TokenType::D_PAR_CLO },
    { '[', TokenType::D_BRAC_OP },
    { ']', TokenType::D_BRAC_CLO },
    { '{', TokenType::D_CBRAC_OP },
    { '}', TokenType::D_CBRAC_CLO },
    { '\n', TokenType::NEW_LINE },
    { '\t', TokenType::TAB },
    { ',', TokenType::COMMA },
    { '@', TokenType::AT_SYMBOL },
};
